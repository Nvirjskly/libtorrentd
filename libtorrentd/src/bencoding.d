// Written in the D programming language

/*	Copyright Andrey A Popov 2012
 * 
 *	Permission is hereby granted, free of charge, to any person or organization
 *	obtaining a copy of the software and accompanying documentation covered by
 *	this license (the "Software") to use, reproduce, display, distribute,
 *	execute, and transmit the Software, and to prepare derivative works of the
 *	Software, and to permit third-parties to whom the Software is furnished to
 *	do so, all subject to the following:
 *	
 *	The copyright notices in the Software and this entire statement, including
 *	the above license grant, this restriction and the following disclaimer,
 *	must be included in all copies of the Software, in whole or in part, and
 *	all derivative works of the Software, unless such copies or derivative
 *	works are solely in the form of machine-executable object code generated by
 *	a source language processor.
 *	
 *	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *	FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 *	SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 *	FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 *	ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *	DEALINGS IN THE SOFTWARE.
 */


/**
 * Authors: Andrey A. Popov, andrey.anat.popov@gmail.com
 */

module bencoding;

import std.string, std.array, std.stdio;

enum BENCODE_TYPE { STRING, INTEGER, LIST, DICTIONARY, NULL };

class bencode
{
	BENCODE_TYPE type;
	string value;
	bencode benvalue; //support recursion.
}


bencode[] ben_decode(string s)
{
	bencode[] ret = [];
	BENCODE_TYPE getType(dchar c)
	{
		writefln("%x",c);
		if ( c >= 0x30 && c <= 0x39 )
			return BENCODE_TYPE.STRING;
		else if ( c	== 'i' )
			return BENCODE_TYPE.INTEGER;
		else if ( c == 'l' )
			return BENCODE_TYPE.LIST;
		else if ( c == 'd')
			return BENCODE_TYPE.DICTIONARY;
		else
			return BENCODE_TYPE.NULL;
	}
	
	ulong stringToInt(dchar[] ds)
	{
		ulong a = 0;
		ulong l = 0;
		while(ds.length > 0)
		{
			ulong d = ds.back()-0x30;
			ds.popBack();
			a += d * (10^^l);
			l++;
		}
		return a;//Too lazy to implement atm;
	}
	
	char[] cs = (cast(char*)toStringz(s))[0..s.length];
	//cs.popFront();
	while (cs.length > 0)
	{
		dchar front = cs.front();
		cs.popFront();
		auto  type = getType(front);
		writeln(type);
		if(type == BENCODE_TYPE.STRING)
		{
			dchar[] length = [];
			length ~= front;
			auto front2 = cs.front();
			cs.popFront();
			while(getType(front2) == BENCODE_TYPE.STRING)
			{
				length ~= front2;
				front2 = cs.front();
				cs.popFront();//last one is :
			}
			auto lengthI = stringToInt(length);
			writeln(lengthI);
			string ss;
			for (ulong i = 0; i < lengthI; i++)
			{
				ss ~= cs.front();
				cs.popFront();
			}
			writeln(ss);
			bencode strben;
			strben.type = BENCODE_TYPE.STRING;
			strben.value = ss;
			ret ~= strben;
		}
	}
	
	
	return ret;
}





